% Лабораторная работа № 1 «Введение в функциональное
  программирование на языке Scala»
% 6 марта 2024 г.
% Илья Афанасьев, ИУ9-61Б

# Цель работы
Целью данной работы является ознакомление с программированием на языке Scala на
основе чистых функций.

# Индивидуальный вариант
Закаренная функция `comb: Int => (List[Int] => List[List[Int]])`, формирующая
список всех сочетаний элементов списка целых чисел. Размер сочетания передаётся
через параметр функции.

# Реализация и тестирование

Работа в REPL-интерпретаторе Scala:

```scala
scala> // the first way
     | val attachHead: (Int, List[List[Int]]) => List[List[Int]] = {
     |   case (x, Nil) => Nil
     |   case (x, l :: ls) => (x :: l) :: attachHead(x, ls)
     | }
     | 
     | val comb1: Int => (List[Int] => List[List[Int]]) =
     |   k => {
     |     case xs if (k == 0) => List(List())
     |     case Nil => Nil
     |     case x :: xs => attachHead(x, comb1(k - 1)(xs)) ::: comb1(k)(xs)
     |   }
     | 
     | // the second way
     | val comb2: Int => (List[Int] => List[List[Int]]) =
     |   k => {
     |     def combInner: (List[Int], Int, List[Int]) => List[List[Int]] = {
     |       case (xs, k, s) if (xs.length < k) => Nil
     |       case (xs, k, s) if (k == 0) => List(s)
     |       case (x :: xs, k, s) => combInner(xs, k, s) :::
                                     combInner(xs, k - 1, x :: s)
     |     }
     | 
     |     combInner(_: List[Int], k, List())
     |   }
     | 

scala> comb1(3)(List(2, 3, 5, 8, 13))
val res0: List[List[Int]] = List(List(2, 3, 5), List(2, 3, 8), List(2, 3, 13),
List(2, 5, 8), List(2, 5, 13), List(2, 8, 13), List(3, 5, 8), List(3, 5, 13),
List(3, 8, 13), List(5, 8, 13))

scala> comb2(3)(List(2, 3, 5, 8, 13))
val res1: List[List[Int]] = List(List(13, 8, 5), List(13, 8, 3), List(13, 5, 3),
List(8, 5, 3), List(13, 8, 2), List(13, 5, 2), List(8, 5, 2), List(13, 3, 2),
List(8, 3, 2), List(5, 3, 2))
```

# Вывод
В результате выполнения лабораторной работы я познакомился с ЯП Scala
и реализовал две чистые закаренные функции, формирующие список всех
сочетаний элементов списка целых чисел. Поскольку в работе нельзя использовать
библиотечные функции высших порядоков (в частности, `map`), первая версия
`comb1` использует вспомогательную функцию `attachHead`, прикрепляющую элемент
в начало нескольких списков. Вторая версия `comb2` возвращает параметризованную
числом сочетаний `k` внутреннюю функцию `combInner`.

Язык Scala мне показался интересным для освоения в силу, в первую очередь,
своих функциональных возможностей. Мне приходилось работать с Refal-5,
где повсеместно используются сопоставление с образцом, функции высших порядков
и каррирование. Было приятно увидеть и попробовать все эти возможности в
Scala.
